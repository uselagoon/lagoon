import { Pool } from 'mariadb';
import { query } from '../../util/db';
import { Sql } from './sql';

export const AnnotationLimit = 10;
export const PathRoutesLimit = 10;
export const AlternativeDomainsLimit = 25;

export const Helpers = (sqlClientPool: Pool) => {
  const removeAllRoutesFromEnvironment = async (environmentId: number) => {
    await query(
      sqlClientPool,
      Sql.removeAllRoutesFromEnvironment(environmentId)
    )
  }
  const deleteAutogeneratedRoutesForEnvironment = async (environmentId: number) => {
    await query(
      sqlClientPool,
      Sql.deleteAutogeneratedRoutesForEnvironment(environmentId)
    )
  }
  const deleteLagoonYAMLRoutesForEnvironment = async (environmentId: number) => {
    await query(
      sqlClientPool,
      Sql.deleteLagoonYAMLRoutesForEnvironment(environmentId)
    )
  }
  const removeRouteFromEnvironment = async (domain: string, environmentId: number) => {
    const routes = await query(
      sqlClientPool,
      Sql.selectRoutesByDomainAndEnvironmentID(domain, environmentId)
    )
    if (routes.length == 0) {
      throw new Error(`Route doesn't exist on this environment`);
    }
    const route = routes[0]
    await query(
      sqlClientPool,
      Sql.removeRouteFromEnvironment(route.id)
    )
    return route.id
  };
  const addRouteAnnotation = async (routeId: number, key: string, value: string) => {
    const existingAnnotations = await query(sqlClientPool, Sql.selectRouteAnnotationsByRouteID(routeId))
    const exists = existingAnnotations.some(
      (a) => a.key === key && a.value === value
    );
    if (exists) {
      throw new Error(`Annotation already exists on route`);
    } else {
      const combinedAnnotationCount = existingAnnotations.length + 1
      // arbitrary limit of 10 annotations, maybe this should be less?
      // would prefer that annotations done this way weren't a thing, but here we are
      if (combinedAnnotationCount >= AnnotationLimit) {
        throw Error(`Limit of ${AnnotationLimit} annotations per route`)
      }
      await query(
        sqlClientPool,
        Sql.insertRouteAnnotation({routeId, key, value})
      )
    }
  }
  const addRouteAnnotations = async (routeId: number, annotations: RouteAnnotations) => {
    const existingAnnotations = await query(sqlClientPool, Sql.selectRouteAnnotationsByRouteID(routeId))
    for(const annotation of annotations) {
      const exists = existingAnnotations.some(
        (a) => a.key === annotation.key && a.value === annotation.value
      );
      if (exists) {
        throw new Error(`Annotation already exists on route`);
      }
      const combinedAnnotationCount = existingAnnotations.length + annotations.length
      // arbitrary limit of 10 annotations, maybe this should be less?
      // would prefer that annotations done this way weren't a thing, but here we are
      if (combinedAnnotationCount >= AnnotationLimit) {
        throw Error(`Limit of ${AnnotationLimit} annotations per route`)
      }
    }
    for(const annotation of annotations) {
      await query(
        sqlClientPool,
        Sql.insertRouteAnnotation({routeId, key: annotation.key, value: annotation.value})
      )
    }
  }
  const deleteRouteAnnotation = async (routeId: number, key: string) => {
    await query(
      sqlClientPool,
      Sql.deleteRoutesAnnotation(routeId, key)
    )
  }
  const deleteRouteAnnotations = async (routeId: number) => {
    await query(
      sqlClientPool,
      Sql.deleteRoutesAnnotations(routeId)
    )
  }

  return {
    removeAllRoutesFromEnvironment,
    deleteAutogeneratedRoutesForEnvironment,
    deleteLagoonYAMLRoutesForEnvironment,
    removeRouteFromEnvironment,
    addRouteAnnotation,
    addRouteAnnotations,
    deleteRouteAnnotation,
    deleteRouteAnnotations
  }
}

export function addServicePathRoute(
  pathRoutes: PathRoutes,
  newToService: string,
  newPath: string
): PathRoutes {
  const exists = pathRoutes.some(
    (a) => a.toService === newToService && a.path === newPath
  );
  const combinedPathRoutesCount = pathRoutes.length + 1
  if (combinedPathRoutesCount >= PathRoutesLimit) {
    throw Error(`Limit of ${PathRoutesLimit} path routes, consider removing some from this route`)
  }
  if (!exists) {
    return [...pathRoutes, { toService: newToService, path: newPath }];
  }

  return pathRoutes;
}

export type RouteAnnotation = {
    key: string;
    value: string;
};

export type RouteAnnotations = RouteAnnotation[];

export type PathRoute = {
    toService: string;
    path: string;
};

export type PathRoutes = PathRoute[];

export type AutoGenPathRoute = {
    fromService: string;
    toService: string;
    path: string;
}

export type AutoGenPathRoutes = AutoGenPathRoute[];

export function removeServicePathRoute(
  pathRoutes: PathRoutes,
  targetToService: string,
  targetPath: string
): PathRoutes {
  return pathRoutes.filter(
    (a) => !(a.toService === targetToService && a.path === targetPath)
  );
}

export function addAutogenServicePathRoute(
  pathRoutes: AutoGenPathRoutes,
  newFromService: string,
  newToService: string,
  newPath: string
): AutoGenPathRoutes {
  const exists = pathRoutes.some(
    (a) => a.toService === newToService && a.path === newPath
  );

  if (!exists) {
    return [...pathRoutes, { fromService: newFromService, toService: newToService, path: newPath }];
  }

  return pathRoutes;
}

export function removeAutogenServicePathRoute(
  pathRoutes: AutoGenPathRoutes,
  targetFromService: string,
  targetToService: string,
  targetPath: string
): AutoGenPathRoutes {
  return pathRoutes.filter(
    (a) => !(a.fromService === targetFromService &&a.toService === targetToService && a.path === targetPath)
  );
}