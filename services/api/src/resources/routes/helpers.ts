import { Pool } from 'mariadb';
import { query } from '../../util/db';
import { Sql } from './sql';
import { isDNS1123Subdomain } from '../../util/func';
import { logger } from '../../loggers/logger';

export const AnnotationLimit = 10;
export const PathRoutesLimit = 10;
export const AlternativeDomainsLimit = 25;
export const AutogeneratedPathRoutesLimit = 10;

export const Helpers = (sqlClientPool: Pool) => {
  const removeAllRoutesFromEnvironment = async (environmentId: number) => {
    await query(
      sqlClientPool,
      Sql.removeAllRoutesFromEnvironment(environmentId)
    )
  }
  const deleteAutogeneratedRoutesForEnvironment = async (environmentId: number) => {
    await query(
      sqlClientPool,
      Sql.deleteAutogeneratedRoutesForEnvironment(environmentId)
    )
  }
  const deleteLagoonYAMLRoutesForEnvironment = async (environmentId: number) => {
    await query(
      sqlClientPool,
      Sql.deleteLagoonYAMLRoutesForEnvironment(environmentId)
    )
  }
  const deleteAutogeneratedRouteConfigForEnvironment = async (environmentId: number) => {
    await query(
      sqlClientPool,
      Sql.deleteAutogeneratedRouteConfigForEnvironment(environmentId)
    )
  }
  const deleteAutogeneratedRouteConfigForProject = async (environmentId: number) => {
    await query(
      sqlClientPool,
      Sql.deleteAutogeneratedRouteConfigForProject(environmentId)
    )
  }
  const removeRouteFromEnvironment = async (domain: string, environmentId: number) => {
    const routes = await query(
      sqlClientPool,
      Sql.selectRoutesByDomainAndEnvironmentID(domain, environmentId)
    )
    if (routes.length == 0) {
      throw new Error(`Route doesn't exist on this environment`);
    }
    const route = routes[0]
    await query(
      sqlClientPool,
      Sql.removeRouteFromEnvironment(route.id)
    )
    return route.id
  };
  const checkAnnotationRequirements = async (routeId: number, annotations: RouteAnnotations) => {
    for(const annotation of annotations) {
      const existingAnnotations = await query(sqlClientPool, Sql.selectRouteAnnotationsByRouteID(routeId))
      const exists = existingAnnotations.some(
        (a) => a.key === annotation.key && a.value === annotation.value
      );
      if (exists) {
        throw new Error(`Annotation already exists on route`);
      } else {
        const combinedAnnotationCount = existingAnnotations.length + 1
        // arbitrary limit of 10 annotations, maybe this should be less?
        // would prefer that annotations done this way weren't a thing, but here we are
        if (combinedAnnotationCount >= AnnotationLimit) {
          throw Error(`Limit of ${AnnotationLimit} annotations per route`)
        }
      }
    }
  };
  const checkDuplicateAnnotations = async (annotations: RouteAnnotations) => {
    const normalized = annotations.map(item => item.key.trim().toLowerCase());
    if (new Set(normalized).size !== normalized.length) {
      throw Error(`Duplicate annotation keys provided in annotations`)
    }
    if (annotations.length >= AnnotationLimit) {
      throw Error(`Limit of ${AnnotationLimit} annotations per route`)
    }
  };
  const checkAlternativeNamesRequirements = async (alternativeNames: string[], projectId: number, routeId?: number) => {
    // check if the limit is not exceeded
    let existingNames = 0
    if (routeId) {
      const existingAltNames = await query(
        sqlClientPool,
        Sql.selectRouteAlternativeDomainsByRouteID(routeId)
      )
      existingNames = existingAltNames.length
    }
    const combinedAltDomainCount = existingNames + alternativeNames.length
    if (combinedAltDomainCount >= AlternativeDomainsLimit) {
      throw Error(`Limit of ${AlternativeDomainsLimit} alternative domains, consider removing some from this route, or create a new route`)
    }
    // if not exceeded, validate and check if not already exists
    for (const d of alternativeNames) {
      // check if the domain is valid dns subdomain
      if (!isDNS1123Subdomain(d)) {
        throw Error(`'${d}' is not a valid domain`)
      }
      const exists = await query(
        sqlClientPool,
        Sql.selectRouteByDomainAndProjectID(d, projectId)
      )
      const exists2 = await query(
        sqlClientPool,
        Sql.selectRouteAlternativeDomainsByDomainAndProjectID(d, projectId)
      )
      // if the domains provided don't already exist, then add them
      if (exists.length > 0 || exists2.length > 0) {
        throw Error(`Route already exists in this project`)
      }
    }
  }
  const checkDuplicateAlternativeNames = async (domainName: string, alternativeNames: string[]) => {
    for (const d of alternativeNames) {
      // trim spaces from the alternate domain as part of comparison check
      const altDomain = d.trim()
      if (altDomain == domainName) {
        throw Error(`Main domain included in alternate domains`)
      }
    }
    if (hasDuplicates(alternativeNames)) {
      throw Error(`Duplicate domains provided in alternate domains`)
    }
  };
  const addRouteAnnotations = async (routeId: number, annotations: RouteAnnotations) => {
    for(const annotation of annotations) {
      await query(
        sqlClientPool,
        Sql.insertRouteAnnotation({routeId, key: annotation.key, value: annotation.value})
      )
    }
  }
  const deleteRouteAnnotation = async (routeId: number, key: string) => {
    await query(
      sqlClientPool,
      Sql.deleteRoutesAnnotation(routeId, key)
    )
  }
  const deleteRouteAnnotations = async (routeId: number) => {
    await query(
      sqlClientPool,
      Sql.deleteRoutesAnnotations(routeId)
    )
  }

  return {
    removeAllRoutesFromEnvironment,
    deleteAutogeneratedRoutesForEnvironment,
    deleteLagoonYAMLRoutesForEnvironment,
    removeRouteFromEnvironment,
    addRouteAnnotations,
    checkAnnotationRequirements,
    checkDuplicateAnnotations,
    checkAlternativeNamesRequirements,
    checkDuplicateAlternativeNames,
    deleteRouteAnnotation,
    deleteRouteAnnotations,
    deleteAutogeneratedRouteConfigForEnvironment,
    deleteAutogeneratedRouteConfigForProject,
  }
}

export function addServicePathRoute(
  pathRoutes: PathRoutes,
  newToService: string,
  newPath: string
): PathRoutes {
  const exists = pathRoutes.some(
    (a) => a.toService === newToService && a.path === newPath
  );
  if (!exists) {
    return [...pathRoutes, { toService: newToService, path: newPath }];
  }

  return pathRoutes;
}

export function checkServicePathRouteRequirements(
  existingPathRoutes: PathRoutes,
  pathRoutes: PathRoutes,
) {
  const combinedPathRoutesCount = pathRoutes.length + existingPathRoutes.length
  if (combinedPathRoutesCount > PathRoutesLimit) {
    throw Error(`Limit of ${PathRoutesLimit} path routes, consider removing some from this route`)
  }
}

export function checkServiceAutoGenPathRouteRequirements(
  pathRoutes: AutoGenPathRoutes,
) {
  if (pathRoutes.length > AutogeneratedPathRoutesLimit) {
    throw Error(`Limit of ${AutogeneratedPathRoutesLimit} path routes for autogenerated routes`)
  }
}

export type RouteAnnotation = {
    key: string;
    value: string;
};

export type RouteAnnotations = RouteAnnotation[];

export type PathRoute = {
    toService: string;
    path: string;
};

export type PathRoutes = PathRoute[];

export type AutoGenPathRoute = {
    fromService: string;
    toService: string;
    path: string;
}

export type AutoGenPathRoutes = AutoGenPathRoute[];

export function removeServicePathRoute(
  pathRoutes: PathRoutes,
  targetToService: string,
  targetPath: string
): PathRoutes {
  return pathRoutes.filter(
    (a) => !(a.toService === targetToService && a.path === targetPath)
  );
}

export function addAutogenServicePathRoute(
  pathRoutes: AutoGenPathRoutes,
  newFromService: string,
  newToService: string,
  newPath: string
): AutoGenPathRoutes {
  const exists = pathRoutes.some(
    (a) => a.toService === newToService && a.path === newPath
  );

  if (!exists) {
    return [...pathRoutes, { fromService: newFromService, toService: newToService, path: newPath }];
  }

  return pathRoutes;
}

export function removeAutogenServicePathRoute(
  pathRoutes: AutoGenPathRoutes,
  targetFromService: string,
  targetToService: string,
  targetPath: string
): AutoGenPathRoutes {
  return pathRoutes.filter(
    (a) => !(a.fromService === targetFromService &&a.toService === targetToService && a.path === targetPath)
  );
}

// check array for duplicates that are trimmed and lowercased
function hasDuplicates(arr) {
  const normalized = arr.map(item => item.trim().toLowerCase());
  return new Set(normalized).size !== normalized.length;
}