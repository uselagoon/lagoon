package lagoon

import (
	"crypto/sha256"
	"encoding/base64"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"math/rand"
	"strconv"
	"time"

	"github.com/uselagoon/machinery/api/schema"
	"github.com/uselagoon/machinery/utils/variables"
)

// change the default route type for one from the
type APIRoute struct {
	schema.Route
	Annotations      map[string]string `json:"annotations"`
	AlternativeNames []string          `json:"alternativeNames"`
}

type APIRoutes struct {
	Routes []APIRoute `json:"routes"`
}

func getRouterPatternAndVariables(
	project schema.Project,
	environment schema.Environment,
	deployTarget schema.DeployTarget,
	bulkID, bulkName string,
	buildPriority int,
	buildVariables []schema.EnvKeyValue,
	bulkType BulkType,
) (string, []schema.EnvKeyValue) {
	appliedEnvVars := []schema.EnvKeyValue{}
	routerPattern := project.DeployTarget.RouterPattern
	if deployTarget.RouterPattern != "" {
		routerPattern = deployTarget.RouterPattern
	}
	if project.RouterPattern != "" {
		routerPattern = project.RouterPattern
	}

	agPayload := &schema.AutogeneratedRouteConfig{}
	hasAGConfig := false
	// check if project autogenerated route configuration is available
	if project.AutogeneratedRouteConfig != nil {
		// set it if so
		agPayload = project.AutogeneratedRouteConfig
		hasAGConfig = true
	}
	// if there is any environment based autogenerated route configurations
	if environment.AutogeneratedRouteConfig != nil {
		// this will override what is set at the project
		agPayload = environment.AutogeneratedRouteConfig
		hasAGConfig = true
	}

	apiRoutes := APIRoutes{}
	for _, route := range environment.APIRoutes {
		if route.Source == schema.APIRoute {
			altNames := []string{}
			// convert any alternative names to type required for the build-deploy-tool
			for _, altName := range route.AlternativeNames {
				altNames = append(altNames, altName.Domain)
			}
			annotations := make(map[string]string)
			// convert any annotations to type required for the build-deploy-tool
			for _, annotation := range route.Annotations {
				annotations[annotation.Key] = annotation.Value
			}
			// convert the route to type required for the build-deploy-tool
			apiRoutes.Routes = append(apiRoutes.Routes, APIRoute{
				route,
				annotations,
				altNames,
			})
		}
	}
	/*
		Internal scoped env vars.

		Uses the env vars system to send data to lagoon-remote but should not be
		overrideable by Lagoon API env vars.
	*/
	appliedEnvVars = append(appliedEnvVars, schema.EnvKeyValue{
		Name:  "LAGOON_SYSTEM_CORE_VERSION",
		Value: variables.GetEnv("LAGOON_VERSION", "unknown"),
		Scope: "internal_system",
	})
	appliedEnvVars = append(appliedEnvVars, schema.EnvKeyValue{
		Name:  "LAGOON_SYSTEM_ROUTER_PATTERN",
		Value: routerPattern,
		Scope: "internal_system",
	})
	bucket, shared := getBAASBucketName(project, deployTarget)
	if shared {
		appliedEnvVars = append(appliedEnvVars, schema.EnvKeyValue{
			Name:  "LAGOON_SYSTEM_PROJECT_SHARED_BUCKET",
			Value: bucket,
			Scope: "internal_system",
		})
	}
	if project.OrganizationDetails != nil {
		appliedEnvVars = append(appliedEnvVars, schema.EnvKeyValue{
			Name:  "LAGOON_ROUTE_QUOTA",
			Value: strconv.Itoa(project.OrganizationDetails.QuotaRoute),
			Scope: "internal_system",
		})
	}
	// handle autogenerated routes and api route payload data
	if agPayload != nil && hasAGConfig {
		agBytes, _ := json.Marshal(agPayload)
		appliedEnvVars = append(appliedEnvVars, schema.EnvKeyValue{
			Name:  "LAGOON_API_AUTOGENERATED_CONFIG",
			Value: base64.StdEncoding.EncodeToString(agBytes),
			Scope: "internal_system",
		})
	}
	if len(project.APIRoutes) > 0 {
		// if the project has any apiroutes defined, then we enforce cleanup of removed routes on any environments
		appliedEnvVars = append(appliedEnvVars, schema.EnvKeyValue{
			Name:  "LAGOON_API_ROUTES_CLEANUP",
			Value: "true",
			Scope: "internal_system",
		})
	}
	if len(apiRoutes.Routes) > 0 {
		// `LAGOON_API_ROUTES` is the successor to LAGOON_ROUTES_JSON. the build-deploy-tool will
		// check if `LAGOON_ROUTES_JSON` is defined, then that will be used to prevent breaking deployments
		// but will produce a build warning indicating that LAGOON_ROUTES_JSON will be deprecated in the future
		// and to use API defined routes instead
		arBytes, _ := json.Marshal(apiRoutes)
		appliedEnvVars = append(appliedEnvVars, schema.EnvKeyValue{
			Name:  "LAGOON_API_ROUTES",
			Value: base64.StdEncoding.EncodeToString(arBytes),
			Scope: "internal_system",
		})
	}
	/*
	   Normally scoped env vars.

	   Env vars that are set by users, or derived from them.
	*/
	// Build env vars passed to the API.
	appliedEnvVars = append(appliedEnvVars, buildVariables...)

	// Bulk deployment vars
	switch bulkType {
	case BulkDeploy:
		appliedEnvVars = append(appliedEnvVars, schema.EnvKeyValue{
			Name:  "LAGOON_BUILD_PRIORITY",
			Value: strconv.Itoa(buildPriority),
			Scope: "build",
		})
		if bulkID != "" {
			appliedEnvVars = append(appliedEnvVars, schema.EnvKeyValue{
				Name:  "LAGOON_BULK_DEPLOY",
				Value: "true",
				Scope: "build",
			})
			appliedEnvVars = append(appliedEnvVars, schema.EnvKeyValue{
				Name:  "LAGOON_BULK_DEPLOY_ID",
				Value: bulkID,
				Scope: "build",
			})
			if bulkName != "" {
				appliedEnvVars = append(appliedEnvVars, schema.EnvKeyValue{
					Name:  "LAGOON_BULK_DEPLOY_NAME",
					Value: bulkName,
					Scope: "build",
				})
			}
		}
	case BulkTask:
		appliedEnvVars = append(appliedEnvVars, schema.EnvKeyValue{
			Name:  "LAGOON_TASK_PRIORITY",
			Value: strconv.Itoa(buildPriority),
			Scope: "build",
		})
		if bulkID != "" {
			appliedEnvVars = append(appliedEnvVars, schema.EnvKeyValue{
				Name:  "LAGOON_BULK_TASK",
				Value: "true",
				Scope: "build",
			})
			appliedEnvVars = append(appliedEnvVars, schema.EnvKeyValue{
				Name:  "LAGOON_BULK_TASK_ID",
				Value: bulkID,
				Scope: "build",
			})
			if bulkName != "" {
				appliedEnvVars = append(appliedEnvVars, schema.EnvKeyValue{
					Name:  "LAGOON_BULK_TASK_NAME",
					Value: bulkName,
					Scope: "build",
				})
			}
		}
	}
	for _, v := range environment.EnvVariables {
		addVarIfNotExist(&appliedEnvVars, schema.EnvKeyValue{
			Name:  v.Name,
			Scope: schema.EnvVariableScope(string(v.Scope)),
			Value: v.Value,
		})
	}
	for _, v := range project.EnvVariables {
		addVarIfNotExist(&appliedEnvVars, schema.EnvKeyValue{
			Name:  v.Name,
			Scope: schema.EnvVariableScope(string(v.Scope)),
			Value: v.Value,
		})
	}
	if project.OrganizationDetails != nil {
		for _, v := range project.OrganizationDetails.EnvVariables {
			addVarIfNotExist(&appliedEnvVars, schema.EnvKeyValue{
				Name:  v.Name,
				Scope: schema.EnvVariableScope(string(v.Scope)),
				Value: v.Value,
			})
		}
	}

	return routerPattern, appliedEnvVars
}

func addVarIfNotExist(envVars *[]schema.EnvKeyValue, envVar schema.EnvKeyValue) {
	exists := false
	for _, e := range *envVars {
		if e.Name == envVar.Name {
			exists = true
		}
	}
	if !exists {
		*envVars = append(*envVars, envVar)
	}
}

func getBAASBucketName(project schema.Project, deploytarget schema.DeployTarget) (string, bool) {
	for _, v := range project.EnvVariables {
		if v.Name == "LAGOON_BAAS_BUCKET_NAME" {
			return v.Value, false
		}
	}
	if project.SharedBaasBucket != nil && *project.SharedBaasBucket {
		return deploytarget.SharedBaasBucketName, true
	}
	return "", false
}

func projectSecret(name, seed string) string {
	data := fmt.Sprintf("%s-%s", name, seed)
	hash := sha256.New()
	hash.Write([]byte(data))
	hashInBytes := hash.Sum(nil)
	return hex.EncodeToString(hashInBytes)
}

func GenerateBuildName() string {
	return fmt.Sprintf("lagoon-build-%s", strconv.FormatInt(rand.New(rand.NewSource(time.Now().UnixNano())).Int63(), 36)[7:])
}

func RemoveToBytes(payload *RemoveData) []byte {
	payloadBytes, _ := json.Marshal(payload)
	return payloadBytes
}
