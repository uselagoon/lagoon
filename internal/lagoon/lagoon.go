package lagoon

import (
	"crypto/sha256"
	"encoding/base64"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"math/rand"
	"strconv"
	"time"

	"github.com/uselagoon/machinery/api/schema"
	"github.com/uselagoon/machinery/utils/namespace"
	"github.com/uselagoon/machinery/utils/variables"
)

func (l *LagoonAPI) GetTaskProjectEnvironmentVariables(
	projectName string,
	environmentId int,
	bulkId string,
	bulkName string,
) (string, []schema.EnvKeyValue, error) {
	project, err := l.ProjectByName(projectName)
	if err != nil {
		return "", nil, err
	}
	environment, err := l.EnvironmentByID(environmentId)
	if err != nil {
		return "", nil, err
	}
	devPriority := uint(5)
	prodPriority := uint(6)
	priority := &devPriority
	if project.DevelopmentBuildPriority != nil {
		priority = project.DevelopmentBuildPriority
	}
	if environment.EnvironmentType == "production" {
		if project.ProductionBuildPriority != nil {
			priority = project.ProductionBuildPriority
		} else {
			priority = &prodPriority
		}
	}
	d := RouterPatternVariablesInput{
		Project:       *project,
		Environment:   *environment,
		DeployTarget:  environment.DeployTarget,
		BuildPriority: priority,
		BulkID:        bulkId,
		BulkName:      bulkName,
		BulkType:      BulkTask,
	}
	routerPattern, envVars := getRouterPatternAndVariables(
		d,
	)
	return routerPattern, envVars, nil
}

func getRouterPatternAndVariables(
	input RouterPatternVariablesInput,
) (string, []schema.EnvKeyValue) {
	appliedEnvVars := []schema.EnvKeyValue{}
	routerPattern := input.Project.DeployTarget.RouterPattern
	if input.DeployTarget.RouterPattern != "" {
		routerPattern = input.DeployTarget.RouterPattern
	}
	if input.Project.RouterPattern != "" {
		routerPattern = input.Project.RouterPattern
	}

	agPayload := &schema.AutogeneratedRouteConfig{}
	hasAGConfig := false
	// check if project autogenerated route configuration is available
	if input.Project.AutogeneratedRouteConfig != nil {
		// set it if so
		agPayload = input.Project.AutogeneratedRouteConfig
		hasAGConfig = true
	}
	// if there is any environment based autogenerated route configurations
	if input.Environment.AutogeneratedRouteConfig != nil {
		// this will override what is set at the project
		agPayload = input.Environment.AutogeneratedRouteConfig
		hasAGConfig = true
	}

	apiRoutes := APIRoutes{}
	for _, route := range input.Environment.APIRoutes {
		if route.Source == schema.APIRoute {
			altNames := []string{}
			// convert any alternative names to type required for the build-deploy-tool
			for _, altName := range route.AlternativeNames {
				altNames = append(altNames, altName.Domain)
			}
			annotations := make(map[string]string)
			// convert any annotations to type required for the build-deploy-tool
			for _, annotation := range route.Annotations {
				annotations[annotation.Key] = annotation.Value
			}
			// convert the route to type required for the build-deploy-tool
			apiRoutes.Routes = append(apiRoutes.Routes, APIRoute{
				route,
				annotations,
				altNames,
			})
		}
	}
	/*
		Internal scoped env vars.

		Uses the env vars system to send data to lagoon-remote but should not be
		overrideable by Lagoon API env vars.
	*/
	appliedEnvVars = append(appliedEnvVars, schema.EnvKeyValue{
		Name:  "LAGOON_SYSTEM_CORE_VERSION",
		Value: variables.GetEnv("LAGOON_VERSION", "unknown"),
		Scope: "internal_system",
	})
	appliedEnvVars = append(appliedEnvVars, schema.EnvKeyValue{
		Name:  "LAGOON_SYSTEM_ROUTER_PATTERN",
		Value: routerPattern,
		Scope: "internal_system",
	})
	bucket, shared := getBAASBucketName(input.Project, input.DeployTarget)
	if shared {
		appliedEnvVars = append(appliedEnvVars, schema.EnvKeyValue{
			Name:  "LAGOON_SYSTEM_PROJECT_SHARED_BUCKET",
			Value: bucket,
			Scope: "internal_system",
		})
	}
	if input.Project.OrganizationDetails != nil {
		appliedEnvVars = append(appliedEnvVars, schema.EnvKeyValue{
			Name:  "LAGOON_ROUTE_QUOTA",
			Value: strconv.Itoa(input.Project.OrganizationDetails.QuotaRoute),
			Scope: "internal_system",
		})
	}
	// handle autogenerated routes and api route payload data
	if agPayload != nil && hasAGConfig {
		agBytes, _ := json.Marshal(agPayload)
		appliedEnvVars = append(appliedEnvVars, schema.EnvKeyValue{
			Name:  "LAGOON_API_AUTOGENERATED_CONFIG",
			Value: base64.StdEncoding.EncodeToString(agBytes),
			Scope: "internal_system",
		})
	}
	if len(input.Project.APIRoutes) > 0 {
		// if the project has any apiroutes defined, then we enforce cleanup of removed routes on any environments
		appliedEnvVars = append(appliedEnvVars, schema.EnvKeyValue{
			Name:  "LAGOON_API_ROUTES_CLEANUP",
			Value: "true",
			Scope: "internal_system",
		})
	}
	if len(apiRoutes.Routes) > 0 {
		// `LAGOON_API_ROUTES` is the successor to LAGOON_ROUTES_JSON. the build-deploy-tool will
		// check if `LAGOON_ROUTES_JSON` is defined, then that will be used to prevent breaking deployments
		// but will produce a build warning indicating that LAGOON_ROUTES_JSON will be deprecated in the future
		// and to use API defined routes instead
		arBytes, _ := json.Marshal(apiRoutes)
		appliedEnvVars = append(appliedEnvVars, schema.EnvKeyValue{
			Name:  "LAGOON_API_ROUTES",
			Value: base64.StdEncoding.EncodeToString(arBytes),
			Scope: "internal_system",
		})
	}
	/*
	   Normally scoped env vars.

	   Env vars that are set by users, or derived from them.
	*/
	// Build env vars passed to the API.
	for _, bVar := range input.BuildVariables {
		appliedEnvVars = append(appliedEnvVars, schema.EnvKeyValue{
			Name:  bVar.Name,
			Value: bVar.Value,
			Scope: "build",
		})
	}

	// Bulk deployment vars
	switch input.BulkType {
	case BulkDeploy:
		appliedEnvVars = append(appliedEnvVars, schema.EnvKeyValue{
			Name:  "LAGOON_BUILD_PRIORITY",
			Value: strconv.FormatUint(uint64(*input.BuildPriority), 10),
			Scope: "build",
		})
		if input.BulkID != "" {
			appliedEnvVars = append(appliedEnvVars, schema.EnvKeyValue{
				Name:  "LAGOON_BULK_DEPLOY",
				Value: "true",
				Scope: "build",
			})
			appliedEnvVars = append(appliedEnvVars, schema.EnvKeyValue{
				Name:  "LAGOON_BULK_DEPLOY_ID",
				Value: input.BulkID,
				Scope: "build",
			})
			if input.BulkName != "" {
				appliedEnvVars = append(appliedEnvVars, schema.EnvKeyValue{
					Name:  "LAGOON_BULK_DEPLOY_NAME",
					Value: input.BulkName,
					Scope: "build",
				})
			}
		}
	case BulkTask:
		appliedEnvVars = append(appliedEnvVars, schema.EnvKeyValue{
			Name:  "LAGOON_TASK_PRIORITY",
			Value: strconv.FormatUint(uint64(*input.BuildPriority), 10),
			Scope: "build",
		})
		if input.BulkID != "" {
			appliedEnvVars = append(appliedEnvVars, schema.EnvKeyValue{
				Name:  "LAGOON_BULK_TASK",
				Value: "true",
				Scope: "build",
			})
			appliedEnvVars = append(appliedEnvVars, schema.EnvKeyValue{
				Name:  "LAGOON_BULK_TASK_ID",
				Value: input.BulkID,
				Scope: "build",
			})
			if input.BulkName != "" {
				appliedEnvVars = append(appliedEnvVars, schema.EnvKeyValue{
					Name:  "LAGOON_BULK_TASK_NAME",
					Value: input.BulkName,
					Scope: "build",
				})
			}
		}
	}
	for _, v := range input.Environment.EnvVariables {
		addVarIfNotExist(&appliedEnvVars, schema.EnvKeyValue{
			Name:  v.Name,
			Scope: schema.EnvVariableScope(string(v.Scope)),
			Value: v.Value,
		})
	}
	for _, v := range input.Project.EnvVariables {
		addVarIfNotExist(&appliedEnvVars, schema.EnvKeyValue{
			Name:  v.Name,
			Scope: schema.EnvVariableScope(string(v.Scope)),
			Value: v.Value,
		})
	}
	if input.Project.OrganizationDetails != nil {
		for _, v := range input.Project.OrganizationDetails.EnvVariables {
			addVarIfNotExist(&appliedEnvVars, schema.EnvKeyValue{
				Name:  v.Name,
				Scope: schema.EnvVariableScope(string(v.Scope)),
				Value: v.Value,
			})
		}
	}

	return routerPattern, appliedEnvVars
}

func addVarIfNotExist(envVars *[]schema.EnvKeyValue, envVar schema.EnvKeyValue) {
	exists := false
	for _, e := range *envVars {
		if e.Name == envVar.Name {
			exists = true
		}
	}
	if !exists {
		*envVars = append(*envVars, envVar)
	}
}

func getBAASBucketName(project schema.Project, deploytarget schema.DeployTarget) (string, bool) {
	for _, v := range project.EnvVariables {
		if v.Name == "LAGOON_BAAS_BUCKET_NAME" {
			return v.Value, false
		}
	}
	if project.SharedBaasBucket != nil && *project.SharedBaasBucket {
		if deploytarget.SharedBaasBucketName == "" {
			return namespace.MakeSafe(deploytarget.Name), true
		} else {
			return deploytarget.SharedBaasBucketName, true
		}
	}
	return "", false
}

func projectSecret(name, seed string) string {
	data := fmt.Sprintf("%s-%s", name, seed)
	hash := sha256.New()
	hash.Write([]byte(data))
	hashInBytes := hash.Sum(nil)
	return hex.EncodeToString(hashInBytes)
}

func GenerateBuildName() string {
	return fmt.Sprintf("lagoon-build-%s", strconv.FormatInt(rand.New(rand.NewSource(time.Now().UnixNano())).Int63(), 36)[7:])
}

func RemoveToBytes(payload *RemoveData) []byte {
	payloadBytes, _ := json.Marshal(payload)
	return payloadBytes
}
